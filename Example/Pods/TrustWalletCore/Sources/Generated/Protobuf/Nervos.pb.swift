// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Nervos.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// SPDX-License-Identifier: Apache-2.0
//
// Copyright Â© 2017 Trust Wallet.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Nervos transaction plan
public struct TW_Nervos_Proto_TransactionPlan {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of cell deps.
  public var cellDeps: [TW_Nervos_Proto_CellDep] = []

  /// A list of header deps.
  public var headerDeps: [Data] = []

  /// A list of 1 or more selected cells for this transaction
  public var selectedCells: [TW_Nervos_Proto_Cell] = []

  /// A list of 1 or more outputs by this transaction
  public var outputs: [TW_Nervos_Proto_CellOutput] = []

  /// A list of outputs data.
  public var outputsData: [Data] = []

  /// Optional error
  public var error: TW_Common_Proto_SigningError = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Nervos cell dep.
public struct TW_Nervos_Proto_CellDep {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Prevents the transaction to be mined before an absolute or relative time
  public var depType: String = String()

  /// Reference to the previous transaction's output.
  public var outPoint: TW_Nervos_Proto_OutPoint {
    get {return _outPoint ?? TW_Nervos_Proto_OutPoint()}
    set {_outPoint = newValue}
  }
  /// Returns true if `outPoint` has been explicitly set.
  public var hasOutPoint: Bool {return self._outPoint != nil}
  /// Clears the value of `outPoint`. Subsequent reads from it will return its default value.
  public mutating func clearOutPoint() {self._outPoint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _outPoint: TW_Nervos_Proto_OutPoint? = nil
}

/// Nervos transaction out-point reference.
public struct TW_Nervos_Proto_OutPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The hash of the referenced transaction.
  public var txHash: Data = Data()

  /// The index of the specific output in the transaction.
  public var index: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Nervos cell output.
public struct TW_Nervos_Proto_CellOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Transaction amount.
  public var capacity: UInt64 = 0

  /// Lock script
  public var lock: TW_Nervos_Proto_Script {
    get {return _lock ?? TW_Nervos_Proto_Script()}
    set {_lock = newValue}
  }
  /// Returns true if `lock` has been explicitly set.
  public var hasLock: Bool {return self._lock != nil}
  /// Clears the value of `lock`. Subsequent reads from it will return its default value.
  public mutating func clearLock() {self._lock = nil}

  /// Type script
  public var type: TW_Nervos_Proto_Script {
    get {return _type ?? TW_Nervos_Proto_Script()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lock: TW_Nervos_Proto_Script? = nil
  fileprivate var _type: TW_Nervos_Proto_Script? = nil
}

/// Nervos script
public struct TW_Nervos_Proto_Script {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Code hash
  public var codeHash: Data = Data()

  /// Hash type
  public var hashType: String = String()

  /// args
  public var args: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Transfer of native asset
public struct TW_Nervos_Proto_NativeTransfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Recipient's address.
  public var toAddress: String = String()

  /// Change address.
  public var changeAddress: String = String()

  /// Amount to send.
  public var amount: UInt64 = 0

  /// If sending max amount.
  public var useMaxAmount: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Token transfer (SUDT)
public struct TW_Nervos_Proto_SudtTransfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Recipient's address.
  public var toAddress: String = String()

  /// Change address.
  public var changeAddress: String = String()

  /// SUDT (Simple User Defined Token) address
  public var sudtAddress: Data = Data()

  /// Amount to send.
  public var amount: String = String()

  /// If sending max amount.
  public var useMaxAmount: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Deposit
public struct TW_Nervos_Proto_DaoDeposit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Recipient's address.
  public var toAddress: String = String()

  /// Change address.
  public var changeAddress: String = String()

  /// Amount to deposit.
  public var amount: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TW_Nervos_Proto_DaoWithdrawPhase1 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deposit cell
  public var depositCell: TW_Nervos_Proto_Cell {
    get {return _depositCell ?? TW_Nervos_Proto_Cell()}
    set {_depositCell = newValue}
  }
  /// Returns true if `depositCell` has been explicitly set.
  public var hasDepositCell: Bool {return self._depositCell != nil}
  /// Clears the value of `depositCell`. Subsequent reads from it will return its default value.
  public mutating func clearDepositCell() {self._depositCell = nil}

  /// Change address.
  public var changeAddress: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _depositCell: TW_Nervos_Proto_Cell? = nil
}

public struct TW_Nervos_Proto_DaoWithdrawPhase2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deposit cell
  public var depositCell: TW_Nervos_Proto_Cell {
    get {return _storage._depositCell ?? TW_Nervos_Proto_Cell()}
    set {_uniqueStorage()._depositCell = newValue}
  }
  /// Returns true if `depositCell` has been explicitly set.
  public var hasDepositCell: Bool {return _storage._depositCell != nil}
  /// Clears the value of `depositCell`. Subsequent reads from it will return its default value.
  public mutating func clearDepositCell() {_uniqueStorage()._depositCell = nil}

  /// Withdrawing cell
  public var withdrawingCell: TW_Nervos_Proto_Cell {
    get {return _storage._withdrawingCell ?? TW_Nervos_Proto_Cell()}
    set {_uniqueStorage()._withdrawingCell = newValue}
  }
  /// Returns true if `withdrawingCell` has been explicitly set.
  public var hasWithdrawingCell: Bool {return _storage._withdrawingCell != nil}
  /// Clears the value of `withdrawingCell`. Subsequent reads from it will return its default value.
  public mutating func clearWithdrawingCell() {_uniqueStorage()._withdrawingCell = nil}

  /// Amount
  public var amount: UInt64 {
    get {return _storage._amount}
    set {_uniqueStorage()._amount = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Input data necessary to create a signed transaction.
public struct TW_Nervos_Proto_SigningInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Transaction fee per byte.
  public var byteFee: UInt64 {
    get {return _storage._byteFee}
    set {_uniqueStorage()._byteFee = newValue}
  }

  /// The available secret private keys used for signing (32 bytes each).
  public var privateKey: [Data] {
    get {return _storage._privateKey}
    set {_uniqueStorage()._privateKey = newValue}
  }

  /// Available unspent cell outputs.
  public var cell: [TW_Nervos_Proto_Cell] {
    get {return _storage._cell}
    set {_uniqueStorage()._cell = newValue}
  }

  /// Optional transaction plan
  public var plan: TW_Nervos_Proto_TransactionPlan {
    get {return _storage._plan ?? TW_Nervos_Proto_TransactionPlan()}
    set {_uniqueStorage()._plan = newValue}
  }
  /// Returns true if `plan` has been explicitly set.
  public var hasPlan: Bool {return _storage._plan != nil}
  /// Clears the value of `plan`. Subsequent reads from it will return its default value.
  public mutating func clearPlan() {_uniqueStorage()._plan = nil}

  /// The payload transfer
  public var operationOneof: OneOf_OperationOneof? {
    get {return _storage._operationOneof}
    set {_uniqueStorage()._operationOneof = newValue}
  }

  public var nativeTransfer: TW_Nervos_Proto_NativeTransfer {
    get {
      if case .nativeTransfer(let v)? = _storage._operationOneof {return v}
      return TW_Nervos_Proto_NativeTransfer()
    }
    set {_uniqueStorage()._operationOneof = .nativeTransfer(newValue)}
  }

  public var sudtTransfer: TW_Nervos_Proto_SudtTransfer {
    get {
      if case .sudtTransfer(let v)? = _storage._operationOneof {return v}
      return TW_Nervos_Proto_SudtTransfer()
    }
    set {_uniqueStorage()._operationOneof = .sudtTransfer(newValue)}
  }

  public var daoDeposit: TW_Nervos_Proto_DaoDeposit {
    get {
      if case .daoDeposit(let v)? = _storage._operationOneof {return v}
      return TW_Nervos_Proto_DaoDeposit()
    }
    set {_uniqueStorage()._operationOneof = .daoDeposit(newValue)}
  }

  public var daoWithdrawPhase1: TW_Nervos_Proto_DaoWithdrawPhase1 {
    get {
      if case .daoWithdrawPhase1(let v)? = _storage._operationOneof {return v}
      return TW_Nervos_Proto_DaoWithdrawPhase1()
    }
    set {_uniqueStorage()._operationOneof = .daoWithdrawPhase1(newValue)}
  }

  public var daoWithdrawPhase2: TW_Nervos_Proto_DaoWithdrawPhase2 {
    get {
      if case .daoWithdrawPhase2(let v)? = _storage._operationOneof {return v}
      return TW_Nervos_Proto_DaoWithdrawPhase2()
    }
    set {_uniqueStorage()._operationOneof = .daoWithdrawPhase2(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The payload transfer
  public enum OneOf_OperationOneof: Equatable {
    case nativeTransfer(TW_Nervos_Proto_NativeTransfer)
    case sudtTransfer(TW_Nervos_Proto_SudtTransfer)
    case daoDeposit(TW_Nervos_Proto_DaoDeposit)
    case daoWithdrawPhase1(TW_Nervos_Proto_DaoWithdrawPhase1)
    case daoWithdrawPhase2(TW_Nervos_Proto_DaoWithdrawPhase2)

  #if !swift(>=4.1)
    public static func ==(lhs: TW_Nervos_Proto_SigningInput.OneOf_OperationOneof, rhs: TW_Nervos_Proto_SigningInput.OneOf_OperationOneof) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.nativeTransfer, .nativeTransfer): return {
        guard case .nativeTransfer(let l) = lhs, case .nativeTransfer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sudtTransfer, .sudtTransfer): return {
        guard case .sudtTransfer(let l) = lhs, case .sudtTransfer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.daoDeposit, .daoDeposit): return {
        guard case .daoDeposit(let l) = lhs, case .daoDeposit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.daoWithdrawPhase1, .daoWithdrawPhase1): return {
        guard case .daoWithdrawPhase1(let l) = lhs, case .daoWithdrawPhase1(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.daoWithdrawPhase2, .daoWithdrawPhase2): return {
        guard case .daoWithdrawPhase2(let l) = lhs, case .daoWithdrawPhase2(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// An unspent cell output, that can serve as input to a transaction
public struct TW_Nervos_Proto_Cell {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unspent output
  public var outPoint: TW_Nervos_Proto_OutPoint {
    get {return _outPoint ?? TW_Nervos_Proto_OutPoint()}
    set {_outPoint = newValue}
  }
  /// Returns true if `outPoint` has been explicitly set.
  public var hasOutPoint: Bool {return self._outPoint != nil}
  /// Clears the value of `outPoint`. Subsequent reads from it will return its default value.
  public mutating func clearOutPoint() {self._outPoint = nil}

  /// Amount of the cell
  public var capacity: UInt64 = 0

  /// Lock script
  public var lock: TW_Nervos_Proto_Script {
    get {return _lock ?? TW_Nervos_Proto_Script()}
    set {_lock = newValue}
  }
  /// Returns true if `lock` has been explicitly set.
  public var hasLock: Bool {return self._lock != nil}
  /// Clears the value of `lock`. Subsequent reads from it will return its default value.
  public mutating func clearLock() {self._lock = nil}

  /// Type script
  public var type: TW_Nervos_Proto_Script {
    get {return _type ?? TW_Nervos_Proto_Script()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  /// Data
  public var data: Data = Data()

  /// Optional block number
  public var blockNumber: UInt64 = 0

  /// Optional block hash
  public var blockHash: Data = Data()

  /// Optional since the cell is available to spend
  public var since: UInt64 = 0

  /// Optional input type data to be included in witness
  public var inputType: Data = Data()

  /// Optional output type data to be included in witness
  public var outputType: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _outPoint: TW_Nervos_Proto_OutPoint? = nil
  fileprivate var _lock: TW_Nervos_Proto_Script? = nil
  fileprivate var _type: TW_Nervos_Proto_Script? = nil
}

/// Result containing the signed and encoded transaction.
public struct TW_Nervos_Proto_SigningOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resulting transaction. Note that the amount may be different than the requested amount to account for fees and available funds.
  public var transactionJson: String = String()

  /// Transaction id
  public var transactionID: String = String()

  /// Optional error
  public var error: TW_Common_Proto_SigningError = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TW.Nervos.Proto"

extension TW_Nervos_Proto_TransactionPlan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionPlan"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cell_deps"),
    2: .standard(proto: "header_deps"),
    3: .standard(proto: "selected_cells"),
    4: .same(proto: "outputs"),
    5: .standard(proto: "outputs_data"),
    6: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cellDeps) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.headerDeps) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.selectedCells) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      case 5: try { try decoder.decodeRepeatedBytesField(value: &self.outputsData) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cellDeps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cellDeps, fieldNumber: 1)
    }
    if !self.headerDeps.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.headerDeps, fieldNumber: 2)
    }
    if !self.selectedCells.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.selectedCells, fieldNumber: 3)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 4)
    }
    if !self.outputsData.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.outputsData, fieldNumber: 5)
    }
    if self.error != .ok {
      try visitor.visitSingularEnumField(value: self.error, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Nervos_Proto_TransactionPlan, rhs: TW_Nervos_Proto_TransactionPlan) -> Bool {
    if lhs.cellDeps != rhs.cellDeps {return false}
    if lhs.headerDeps != rhs.headerDeps {return false}
    if lhs.selectedCells != rhs.selectedCells {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.outputsData != rhs.outputsData {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Nervos_Proto_CellDep: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CellDep"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dep_type"),
    2: .standard(proto: "out_point"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.depType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outPoint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.depType.isEmpty {
      try visitor.visitSingularStringField(value: self.depType, fieldNumber: 1)
    }
    try { if let v = self._outPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Nervos_Proto_CellDep, rhs: TW_Nervos_Proto_CellDep) -> Bool {
    if lhs.depType != rhs.depType {return false}
    if lhs._outPoint != rhs._outPoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Nervos_Proto_OutPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_hash"),
    2: .same(proto: "index"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txHash) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.txHash, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Nervos_Proto_OutPoint, rhs: TW_Nervos_Proto_OutPoint) -> Bool {
    if lhs.txHash != rhs.txHash {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Nervos_Proto_CellOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CellOutput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "capacity"),
    2: .same(proto: "lock"),
    3: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.capacity) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._lock) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.capacity != 0 {
      try visitor.visitSingularUInt64Field(value: self.capacity, fieldNumber: 1)
    }
    try { if let v = self._lock {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Nervos_Proto_CellOutput, rhs: TW_Nervos_Proto_CellOutput) -> Bool {
    if lhs.capacity != rhs.capacity {return false}
    if lhs._lock != rhs._lock {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Nervos_Proto_Script: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Script"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "code_hash"),
    2: .standard(proto: "hash_type"),
    3: .same(proto: "args"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.codeHash) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hashType) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.args) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.codeHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.codeHash, fieldNumber: 1)
    }
    if !self.hashType.isEmpty {
      try visitor.visitSingularStringField(value: self.hashType, fieldNumber: 2)
    }
    if !self.args.isEmpty {
      try visitor.visitSingularBytesField(value: self.args, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Nervos_Proto_Script, rhs: TW_Nervos_Proto_Script) -> Bool {
    if lhs.codeHash != rhs.codeHash {return false}
    if lhs.hashType != rhs.hashType {return false}
    if lhs.args != rhs.args {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Nervos_Proto_NativeTransfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NativeTransfer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "to_address"),
    2: .standard(proto: "change_address"),
    3: .same(proto: "amount"),
    4: .standard(proto: "use_max_amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.toAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.changeAddress) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.useMaxAmount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.toAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.toAddress, fieldNumber: 1)
    }
    if !self.changeAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.changeAddress, fieldNumber: 2)
    }
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 3)
    }
    if self.useMaxAmount != false {
      try visitor.visitSingularBoolField(value: self.useMaxAmount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Nervos_Proto_NativeTransfer, rhs: TW_Nervos_Proto_NativeTransfer) -> Bool {
    if lhs.toAddress != rhs.toAddress {return false}
    if lhs.changeAddress != rhs.changeAddress {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.useMaxAmount != rhs.useMaxAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Nervos_Proto_SudtTransfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SudtTransfer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "to_address"),
    2: .standard(proto: "change_address"),
    3: .standard(proto: "sudt_address"),
    4: .same(proto: "amount"),
    5: .standard(proto: "use_max_amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.toAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.changeAddress) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.sudtAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.useMaxAmount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.toAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.toAddress, fieldNumber: 1)
    }
    if !self.changeAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.changeAddress, fieldNumber: 2)
    }
    if !self.sudtAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.sudtAddress, fieldNumber: 3)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 4)
    }
    if self.useMaxAmount != false {
      try visitor.visitSingularBoolField(value: self.useMaxAmount, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Nervos_Proto_SudtTransfer, rhs: TW_Nervos_Proto_SudtTransfer) -> Bool {
    if lhs.toAddress != rhs.toAddress {return false}
    if lhs.changeAddress != rhs.changeAddress {return false}
    if lhs.sudtAddress != rhs.sudtAddress {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.useMaxAmount != rhs.useMaxAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Nervos_Proto_DaoDeposit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DaoDeposit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "to_address"),
    2: .standard(proto: "change_address"),
    3: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.toAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.changeAddress) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.toAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.toAddress, fieldNumber: 1)
    }
    if !self.changeAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.changeAddress, fieldNumber: 2)
    }
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Nervos_Proto_DaoDeposit, rhs: TW_Nervos_Proto_DaoDeposit) -> Bool {
    if lhs.toAddress != rhs.toAddress {return false}
    if lhs.changeAddress != rhs.changeAddress {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Nervos_Proto_DaoWithdrawPhase1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DaoWithdrawPhase1"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "deposit_cell"),
    2: .standard(proto: "change_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._depositCell) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.changeAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._depositCell {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.changeAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.changeAddress, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Nervos_Proto_DaoWithdrawPhase1, rhs: TW_Nervos_Proto_DaoWithdrawPhase1) -> Bool {
    if lhs._depositCell != rhs._depositCell {return false}
    if lhs.changeAddress != rhs.changeAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Nervos_Proto_DaoWithdrawPhase2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DaoWithdrawPhase2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "deposit_cell"),
    2: .standard(proto: "withdrawing_cell"),
    3: .same(proto: "amount"),
  ]

  fileprivate class _StorageClass {
    var _depositCell: TW_Nervos_Proto_Cell? = nil
    var _withdrawingCell: TW_Nervos_Proto_Cell? = nil
    var _amount: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _depositCell = source._depositCell
      _withdrawingCell = source._withdrawingCell
      _amount = source._amount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._depositCell) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._withdrawingCell) }()
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._amount) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._depositCell {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._withdrawingCell {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._amount != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._amount, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Nervos_Proto_DaoWithdrawPhase2, rhs: TW_Nervos_Proto_DaoWithdrawPhase2) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._depositCell != rhs_storage._depositCell {return false}
        if _storage._withdrawingCell != rhs_storage._withdrawingCell {return false}
        if _storage._amount != rhs_storage._amount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Nervos_Proto_SigningInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SigningInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "byte_fee"),
    2: .standard(proto: "private_key"),
    3: .same(proto: "cell"),
    4: .same(proto: "plan"),
    5: .standard(proto: "native_transfer"),
    6: .standard(proto: "sudt_transfer"),
    7: .standard(proto: "dao_deposit"),
    8: .standard(proto: "dao_withdraw_phase1"),
    9: .standard(proto: "dao_withdraw_phase2"),
  ]

  fileprivate class _StorageClass {
    var _byteFee: UInt64 = 0
    var _privateKey: [Data] = []
    var _cell: [TW_Nervos_Proto_Cell] = []
    var _plan: TW_Nervos_Proto_TransactionPlan? = nil
    var _operationOneof: TW_Nervos_Proto_SigningInput.OneOf_OperationOneof?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _byteFee = source._byteFee
      _privateKey = source._privateKey
      _cell = source._cell
      _plan = source._plan
      _operationOneof = source._operationOneof
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._byteFee) }()
        case 2: try { try decoder.decodeRepeatedBytesField(value: &_storage._privateKey) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._cell) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._plan) }()
        case 5: try {
          var v: TW_Nervos_Proto_NativeTransfer?
          var hadOneofValue = false
          if let current = _storage._operationOneof {
            hadOneofValue = true
            if case .nativeTransfer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._operationOneof = .nativeTransfer(v)
          }
        }()
        case 6: try {
          var v: TW_Nervos_Proto_SudtTransfer?
          var hadOneofValue = false
          if let current = _storage._operationOneof {
            hadOneofValue = true
            if case .sudtTransfer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._operationOneof = .sudtTransfer(v)
          }
        }()
        case 7: try {
          var v: TW_Nervos_Proto_DaoDeposit?
          var hadOneofValue = false
          if let current = _storage._operationOneof {
            hadOneofValue = true
            if case .daoDeposit(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._operationOneof = .daoDeposit(v)
          }
        }()
        case 8: try {
          var v: TW_Nervos_Proto_DaoWithdrawPhase1?
          var hadOneofValue = false
          if let current = _storage._operationOneof {
            hadOneofValue = true
            if case .daoWithdrawPhase1(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._operationOneof = .daoWithdrawPhase1(v)
          }
        }()
        case 9: try {
          var v: TW_Nervos_Proto_DaoWithdrawPhase2?
          var hadOneofValue = false
          if let current = _storage._operationOneof {
            hadOneofValue = true
            if case .daoWithdrawPhase2(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._operationOneof = .daoWithdrawPhase2(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._byteFee != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._byteFee, fieldNumber: 1)
      }
      if !_storage._privateKey.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._privateKey, fieldNumber: 2)
      }
      if !_storage._cell.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._cell, fieldNumber: 3)
      }
      try { if let v = _storage._plan {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      switch _storage._operationOneof {
      case .nativeTransfer?: try {
        guard case .nativeTransfer(let v)? = _storage._operationOneof else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .sudtTransfer?: try {
        guard case .sudtTransfer(let v)? = _storage._operationOneof else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .daoDeposit?: try {
        guard case .daoDeposit(let v)? = _storage._operationOneof else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .daoWithdrawPhase1?: try {
        guard case .daoWithdrawPhase1(let v)? = _storage._operationOneof else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .daoWithdrawPhase2?: try {
        guard case .daoWithdrawPhase2(let v)? = _storage._operationOneof else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Nervos_Proto_SigningInput, rhs: TW_Nervos_Proto_SigningInput) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._byteFee != rhs_storage._byteFee {return false}
        if _storage._privateKey != rhs_storage._privateKey {return false}
        if _storage._cell != rhs_storage._cell {return false}
        if _storage._plan != rhs_storage._plan {return false}
        if _storage._operationOneof != rhs_storage._operationOneof {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Nervos_Proto_Cell: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Cell"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "out_point"),
    2: .same(proto: "capacity"),
    3: .same(proto: "lock"),
    4: .same(proto: "type"),
    5: .same(proto: "data"),
    6: .standard(proto: "block_number"),
    7: .standard(proto: "block_hash"),
    8: .same(proto: "since"),
    9: .standard(proto: "input_type"),
    10: .standard(proto: "output_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._outPoint) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.capacity) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._lock) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._type) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.blockNumber) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.blockHash) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.since) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self.inputType) }()
      case 10: try { try decoder.decodeSingularBytesField(value: &self.outputType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._outPoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.capacity != 0 {
      try visitor.visitSingularUInt64Field(value: self.capacity, fieldNumber: 2)
    }
    try { if let v = self._lock {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 5)
    }
    if self.blockNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockNumber, fieldNumber: 6)
    }
    if !self.blockHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.blockHash, fieldNumber: 7)
    }
    if self.since != 0 {
      try visitor.visitSingularUInt64Field(value: self.since, fieldNumber: 8)
    }
    if !self.inputType.isEmpty {
      try visitor.visitSingularBytesField(value: self.inputType, fieldNumber: 9)
    }
    if !self.outputType.isEmpty {
      try visitor.visitSingularBytesField(value: self.outputType, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Nervos_Proto_Cell, rhs: TW_Nervos_Proto_Cell) -> Bool {
    if lhs._outPoint != rhs._outPoint {return false}
    if lhs.capacity != rhs.capacity {return false}
    if lhs._lock != rhs._lock {return false}
    if lhs._type != rhs._type {return false}
    if lhs.data != rhs.data {return false}
    if lhs.blockNumber != rhs.blockNumber {return false}
    if lhs.blockHash != rhs.blockHash {return false}
    if lhs.since != rhs.since {return false}
    if lhs.inputType != rhs.inputType {return false}
    if lhs.outputType != rhs.outputType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Nervos_Proto_SigningOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SigningOutput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_json"),
    2: .standard(proto: "transaction_id"),
    3: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transactionJson) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.transactionID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionJson.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionJson, fieldNumber: 1)
    }
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 2)
    }
    if self.error != .ok {
      try visitor.visitSingularEnumField(value: self.error, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Nervos_Proto_SigningOutput, rhs: TW_Nervos_Proto_SigningOutput) -> Bool {
    if lhs.transactionJson != rhs.transactionJson {return false}
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
