// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: EthereumAbi.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum TW_EthereumAbi_Proto_AbiError: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// This is the OK case, with value=0
  case ok // = 0

  /// Internal error.
  case errorInternal // = 1

  /// Unexpected function signature or ABI mismatch.
  case errorAbiMismatch // = 2

  /// Invalid ABI.
  case errorInvalidAbi // = 3

  /// Invalid parameter type.
  case errorInvalidParamType // = 4

  /// Invalid address value.
  case errorInvalidAddressValue // = 5

  /// Invalid UInt value.
  case errorInvalidUintValue // = 6

  /// Missing parameter type.
  case errorMissingParamType // = 7

  /// Missing parameter value.
  case errorMissingParamValue // = 8

  /// Invalid encoded data.
  case errorDecodingData // = 9

  /// Invalid empty type.
  /// For example, bytes0, address[0].
  case errorEmptyType // = 10
  case UNRECOGNIZED(Int)

  public init() {
    self = .ok
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ok
    case 1: self = .errorInternal
    case 2: self = .errorAbiMismatch
    case 3: self = .errorInvalidAbi
    case 4: self = .errorInvalidParamType
    case 5: self = .errorInvalidAddressValue
    case 6: self = .errorInvalidUintValue
    case 7: self = .errorMissingParamType
    case 8: self = .errorMissingParamValue
    case 9: self = .errorDecodingData
    case 10: self = .errorEmptyType
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .ok: return 0
    case .errorInternal: return 1
    case .errorAbiMismatch: return 2
    case .errorInvalidAbi: return 3
    case .errorInvalidParamType: return 4
    case .errorInvalidAddressValue: return 5
    case .errorInvalidUintValue: return 6
    case .errorMissingParamType: return 7
    case .errorMissingParamValue: return 8
    case .errorDecodingData: return 9
    case .errorEmptyType: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TW_EthereumAbi_Proto_AbiError: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [TW_EthereumAbi_Proto_AbiError] = [
    .ok,
    .errorInternal,
    .errorAbiMismatch,
    .errorInvalidAbi,
    .errorInvalidParamType,
    .errorInvalidAddressValue,
    .errorInvalidUintValue,
    .errorMissingParamType,
    .errorMissingParamValue,
    .errorDecodingData,
    .errorEmptyType,
  ]
}

#endif  // swift(>=4.2)

/// Indicates a boolean type.
public struct TW_EthereumAbi_Proto_BoolType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Generic number type for all bit sizes, like UInt24, 40, 48, ... 248.
public struct TW_EthereumAbi_Proto_NumberNType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of bits of an integer.
  public var bits: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Indicates a string type.
public struct TW_EthereumAbi_Proto_StringType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Indicates an address type.
public struct TW_EthereumAbi_Proto_AddressType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Indicates an array type with an inner `element_type`.
public struct TW_EthereumAbi_Proto_ArrayType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of array elements.
  public var elementType: TW_EthereumAbi_Proto_ParamType {
    get {return _storage._elementType ?? TW_EthereumAbi_Proto_ParamType()}
    set {_uniqueStorage()._elementType = newValue}
  }
  /// Returns true if `elementType` has been explicitly set.
  public var hasElementType: Bool {return _storage._elementType != nil}
  /// Clears the value of `elementType`. Subsequent reads from it will return its default value.
  public mutating func clearElementType() {_uniqueStorage()._elementType = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Indicates a fixed-size array type with an inner `element_type`.
public struct TW_EthereumAbi_Proto_FixedArrayType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The fixed-size of the array.
  public var size: UInt64 {
    get {return _storage._size}
    set {_uniqueStorage()._size = newValue}
  }

  /// The type of array elements.
  public var elementType: TW_EthereumAbi_Proto_ParamType {
    get {return _storage._elementType ?? TW_EthereumAbi_Proto_ParamType()}
    set {_uniqueStorage()._elementType = newValue}
  }
  /// Returns true if `elementType` has been explicitly set.
  public var hasElementType: Bool {return _storage._elementType != nil}
  /// Clears the value of `elementType`. Subsequent reads from it will return its default value.
  public mutating func clearElementType() {_uniqueStorage()._elementType = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Indicates a byte array type.
public struct TW_EthereumAbi_Proto_ByteArrayType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Indicates a fixed-size byte array type.
public struct TW_EthereumAbi_Proto_ByteArrayFixType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The fixed-size of the array.
  public var size: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Indicates a tuple with inner type parameters.
public struct TW_EthereumAbi_Proto_TupleType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Tuple named parameters.
  public var params: [TW_EthereumAbi_Proto_Param] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Named parameter with type.
public struct TW_EthereumAbi_Proto_Param {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the parameter.
  public var name: String = String()

  /// Type of the parameter.
  public var param: TW_EthereumAbi_Proto_ParamType {
    get {return _param ?? TW_EthereumAbi_Proto_ParamType()}
    set {_param = newValue}
  }
  /// Returns true if `param` has been explicitly set.
  public var hasParam: Bool {return self._param != nil}
  /// Clears the value of `param`. Subsequent reads from it will return its default value.
  public mutating func clearParam() {self._param = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _param: TW_EthereumAbi_Proto_ParamType? = nil
}

public struct TW_EthereumAbi_Proto_ParamType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var param: OneOf_Param? {
    get {return _storage._param}
    set {_uniqueStorage()._param = newValue}
  }

  public var boolean: TW_EthereumAbi_Proto_BoolType {
    get {
      if case .boolean(let v)? = _storage._param {return v}
      return TW_EthereumAbi_Proto_BoolType()
    }
    set {_uniqueStorage()._param = .boolean(newValue)}
  }

  public var numberInt: TW_EthereumAbi_Proto_NumberNType {
    get {
      if case .numberInt(let v)? = _storage._param {return v}
      return TW_EthereumAbi_Proto_NumberNType()
    }
    set {_uniqueStorage()._param = .numberInt(newValue)}
  }

  public var numberUint: TW_EthereumAbi_Proto_NumberNType {
    get {
      if case .numberUint(let v)? = _storage._param {return v}
      return TW_EthereumAbi_Proto_NumberNType()
    }
    set {_uniqueStorage()._param = .numberUint(newValue)}
  }

  /// Nested values. Gap in field numbering is intentional.
  public var stringParam: TW_EthereumAbi_Proto_StringType {
    get {
      if case .stringParam(let v)? = _storage._param {return v}
      return TW_EthereumAbi_Proto_StringType()
    }
    set {_uniqueStorage()._param = .stringParam(newValue)}
  }

  public var address: TW_EthereumAbi_Proto_AddressType {
    get {
      if case .address(let v)? = _storage._param {return v}
      return TW_EthereumAbi_Proto_AddressType()
    }
    set {_uniqueStorage()._param = .address(newValue)}
  }

  public var byteArray: TW_EthereumAbi_Proto_ByteArrayType {
    get {
      if case .byteArray(let v)? = _storage._param {return v}
      return TW_EthereumAbi_Proto_ByteArrayType()
    }
    set {_uniqueStorage()._param = .byteArray(newValue)}
  }

  public var byteArrayFix: TW_EthereumAbi_Proto_ByteArrayFixType {
    get {
      if case .byteArrayFix(let v)? = _storage._param {return v}
      return TW_EthereumAbi_Proto_ByteArrayFixType()
    }
    set {_uniqueStorage()._param = .byteArrayFix(newValue)}
  }

  /// Nested values. Gap in field numbering is intentional.
  public var array: TW_EthereumAbi_Proto_ArrayType {
    get {
      if case .array(let v)? = _storage._param {return v}
      return TW_EthereumAbi_Proto_ArrayType()
    }
    set {_uniqueStorage()._param = .array(newValue)}
  }

  public var fixedArray: TW_EthereumAbi_Proto_FixedArrayType {
    get {
      if case .fixedArray(let v)? = _storage._param {return v}
      return TW_EthereumAbi_Proto_FixedArrayType()
    }
    set {_uniqueStorage()._param = .fixedArray(newValue)}
  }

  /// Nested values. Gap in field numbering is intentional.
  public var tuple: TW_EthereumAbi_Proto_TupleType {
    get {
      if case .tuple(let v)? = _storage._param {return v}
      return TW_EthereumAbi_Proto_TupleType()
    }
    set {_uniqueStorage()._param = .tuple(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Param: Equatable {
    case boolean(TW_EthereumAbi_Proto_BoolType)
    case numberInt(TW_EthereumAbi_Proto_NumberNType)
    case numberUint(TW_EthereumAbi_Proto_NumberNType)
    /// Nested values. Gap in field numbering is intentional.
    case stringParam(TW_EthereumAbi_Proto_StringType)
    case address(TW_EthereumAbi_Proto_AddressType)
    case byteArray(TW_EthereumAbi_Proto_ByteArrayType)
    case byteArrayFix(TW_EthereumAbi_Proto_ByteArrayFixType)
    /// Nested values. Gap in field numbering is intentional.
    case array(TW_EthereumAbi_Proto_ArrayType)
    case fixedArray(TW_EthereumAbi_Proto_FixedArrayType)
    /// Nested values. Gap in field numbering is intentional.
    case tuple(TW_EthereumAbi_Proto_TupleType)

  #if !swift(>=4.1)
    public static func ==(lhs: TW_EthereumAbi_Proto_ParamType.OneOf_Param, rhs: TW_EthereumAbi_Proto_ParamType.OneOf_Param) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.boolean, .boolean): return {
        guard case .boolean(let l) = lhs, case .boolean(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.numberInt, .numberInt): return {
        guard case .numberInt(let l) = lhs, case .numberInt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.numberUint, .numberUint): return {
        guard case .numberUint(let l) = lhs, case .numberUint(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stringParam, .stringParam): return {
        guard case .stringParam(let l) = lhs, case .stringParam(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.address, .address): return {
        guard case .address(let l) = lhs, case .address(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.byteArray, .byteArray): return {
        guard case .byteArray(let l) = lhs, case .byteArray(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.byteArrayFix, .byteArrayFix): return {
        guard case .byteArrayFix(let l) = lhs, case .byteArrayFix(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.array, .array): return {
        guard case .array(let l) = lhs, case .array(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fixedArray, .fixedArray): return {
        guard case .fixedArray(let l) = lhs, case .fixedArray(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tuple, .tuple): return {
        guard case .tuple(let l) = lhs, case .tuple(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Generic number parameter for all other bit sizes, like UInt24, 40, 48, ... 248.
public struct TW_EthereumAbi_Proto_NumberNParam {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Count of bits of the number.
  /// 0 < bits <= 256, bits % 8 == 0
  public var bits: UInt32 = 0

  /// Serialized big endian.
  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A byte array of arbitrary size.
public struct TW_EthereumAbi_Proto_ArrayParam {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of array elements.
  public var elementType: TW_EthereumAbi_Proto_ParamType {
    get {return _elementType ?? TW_EthereumAbi_Proto_ParamType()}
    set {_elementType = newValue}
  }
  /// Returns true if `elementType` has been explicitly set.
  public var hasElementType: Bool {return self._elementType != nil}
  /// Clears the value of `elementType`. Subsequent reads from it will return its default value.
  public mutating func clearElementType() {self._elementType = nil}

  /// Array elements.
  public var elements: [TW_EthereumAbi_Proto_Token] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _elementType: TW_EthereumAbi_Proto_ParamType? = nil
}

/// A tuple with various parameters similar to a structure.
public struct TW_EthereumAbi_Proto_TupleParam {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Tokens (values) of the tuple parameters.
  public var params: [TW_EthereumAbi_Proto_Token] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A value of an ABI parameter.
public struct TW_EthereumAbi_Proto_Token {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Name of a corresponding parameter.
  public var name: String = String()

  public var token: TW_EthereumAbi_Proto_Token.OneOf_Token? = nil

  /// Integer values.
  public var boolean: Bool {
    get {
      if case .boolean(let v)? = token {return v}
      return false
    }
    set {token = .boolean(newValue)}
  }

  public var numberInt: TW_EthereumAbi_Proto_NumberNParam {
    get {
      if case .numberInt(let v)? = token {return v}
      return TW_EthereumAbi_Proto_NumberNParam()
    }
    set {token = .numberInt(newValue)}
  }

  public var numberUint: TW_EthereumAbi_Proto_NumberNParam {
    get {
      if case .numberUint(let v)? = token {return v}
      return TW_EthereumAbi_Proto_NumberNParam()
    }
    set {token = .numberUint(newValue)}
  }

  /// Simple values. Gap in field numbering is intentional.
  public var stringValue: String {
    get {
      if case .stringValue(let v)? = token {return v}
      return String()
    }
    set {token = .stringValue(newValue)}
  }

  public var address: String {
    get {
      if case .address(let v)? = token {return v}
      return String()
    }
    set {token = .address(newValue)}
  }

  public var byteArray: Data {
    get {
      if case .byteArray(let v)? = token {return v}
      return Data()
    }
    set {token = .byteArray(newValue)}
  }

  public var byteArrayFix: Data {
    get {
      if case .byteArrayFix(let v)? = token {return v}
      return Data()
    }
    set {token = .byteArrayFix(newValue)}
  }

  /// Nested values. Gap in field numbering is intentional.
  public var array: TW_EthereumAbi_Proto_ArrayParam {
    get {
      if case .array(let v)? = token {return v}
      return TW_EthereumAbi_Proto_ArrayParam()
    }
    set {token = .array(newValue)}
  }

  public var fixedArray: TW_EthereumAbi_Proto_ArrayParam {
    get {
      if case .fixedArray(let v)? = token {return v}
      return TW_EthereumAbi_Proto_ArrayParam()
    }
    set {token = .fixedArray(newValue)}
  }

  /// Nested values. Gap in field numbering is intentional.
  public var tuple: TW_EthereumAbi_Proto_TupleParam {
    get {
      if case .tuple(let v)? = token {return v}
      return TW_EthereumAbi_Proto_TupleParam()
    }
    set {token = .tuple(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Token: Equatable {
    /// Integer values.
    case boolean(Bool)
    case numberInt(TW_EthereumAbi_Proto_NumberNParam)
    case numberUint(TW_EthereumAbi_Proto_NumberNParam)
    /// Simple values. Gap in field numbering is intentional.
    case stringValue(String)
    case address(String)
    case byteArray(Data)
    case byteArrayFix(Data)
    /// Nested values. Gap in field numbering is intentional.
    case array(TW_EthereumAbi_Proto_ArrayParam)
    case fixedArray(TW_EthereumAbi_Proto_ArrayParam)
    /// Nested values. Gap in field numbering is intentional.
    case tuple(TW_EthereumAbi_Proto_TupleParam)

  #if !swift(>=4.1)
    public static func ==(lhs: TW_EthereumAbi_Proto_Token.OneOf_Token, rhs: TW_EthereumAbi_Proto_Token.OneOf_Token) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.boolean, .boolean): return {
        guard case .boolean(let l) = lhs, case .boolean(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.numberInt, .numberInt): return {
        guard case .numberInt(let l) = lhs, case .numberInt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.numberUint, .numberUint): return {
        guard case .numberUint(let l) = lhs, case .numberUint(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stringValue, .stringValue): return {
        guard case .stringValue(let l) = lhs, case .stringValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.address, .address): return {
        guard case .address(let l) = lhs, case .address(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.byteArray, .byteArray): return {
        guard case .byteArray(let l) = lhs, case .byteArray(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.byteArrayFix, .byteArrayFix): return {
        guard case .byteArrayFix(let l) = lhs, case .byteArrayFix(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.array, .array): return {
        guard case .array(let l) = lhs, case .array(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fixedArray, .fixedArray): return {
        guard case .fixedArray(let l) = lhs, case .fixedArray(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tuple, .tuple): return {
        guard case .tuple(let l) = lhs, case .tuple(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Decode a contract call (function input) according to the given ABI json.
public struct TW_EthereumAbi_Proto_ContractCallDecodingInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An encoded smart contract call with a prefixed function signature (4 bytes).
  public var encoded: Data = Data()

  /// A smart contract ABI in JSON.
  /// Each ABI function must be mapped to a short signature.
  /// Expected to be a set of functions mapped to corresponding short signatures.
  /// Example:
  /// ```
  /// {
  ///     "1896f70a": {
  ///         "name": "setResolver",
  ///         "inputs": [...],
  ///         ...
  ///     },
  ///     "ac9650d8": {
  ///         "name": "multicall",
  ///         "inputs": [...],
  ///         ...
  ///     }
  /// }
  /// ```
  public var smartContractAbiJson: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TW_EthereumAbi_Proto_ContractCallDecodingOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Human readable json format, according to the input `ContractCallDecodingInput::smart_contract_abi_json`.
  public var decodedJson: String = String()

  /// Decoded parameters.
  public var tokens: [TW_EthereumAbi_Proto_Token] = []

  /// error code, 0 is ok, other codes will be treated as errors
  public var error: TW_EthereumAbi_Proto_AbiError = .ok

  /// error code description
  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A set of ABI type parameters.
public struct TW_EthereumAbi_Proto_AbiParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ABI type parameters.
  public var params: [TW_EthereumAbi_Proto_Param] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Decode a function input or output data according to the given ABI json.
public struct TW_EthereumAbi_Proto_ParamsDecodingInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An encoded ABI.
  public var encoded: Data = Data()

  public var abi: TW_EthereumAbi_Proto_ParamsDecodingInput.OneOf_Abi? = nil

  /// A set of ABI parameters in JSON.
  /// Expected to be a JSON array at the entry level.
  /// Example:
  /// ```
  /// [
  ///     {
  ///         "name": "_to',
  ///         "type": "address"
  ///     },
  ///     {
  ///         "name": "_value",
  ///         "type": "uint256"
  ///     }
  /// ]
  /// ```
  public var abiJson: String {
    get {
      if case .abiJson(let v)? = abi {return v}
      return String()
    }
    set {abi = .abiJson(newValue)}
  }

  /// A set of ABI type parameters.
  public var abiParams: TW_EthereumAbi_Proto_AbiParams {
    get {
      if case .abiParams(let v)? = abi {return v}
      return TW_EthereumAbi_Proto_AbiParams()
    }
    set {abi = .abiParams(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Abi: Equatable {
    /// A set of ABI parameters in JSON.
    /// Expected to be a JSON array at the entry level.
    /// Example:
    /// ```
    /// [
    ///     {
    ///         "name": "_to',
    ///         "type": "address"
    ///     },
    ///     {
    ///         "name": "_value",
    ///         "type": "uint256"
    ///     }
    /// ]
    /// ```
    case abiJson(String)
    /// A set of ABI type parameters.
    case abiParams(TW_EthereumAbi_Proto_AbiParams)

  #if !swift(>=4.1)
    public static func ==(lhs: TW_EthereumAbi_Proto_ParamsDecodingInput.OneOf_Abi, rhs: TW_EthereumAbi_Proto_ParamsDecodingInput.OneOf_Abi) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.abiJson, .abiJson): return {
        guard case .abiJson(let l) = lhs, case .abiJson(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.abiParams, .abiParams): return {
        guard case .abiParams(let l) = lhs, case .abiParams(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct TW_EthereumAbi_Proto_ParamsDecodingOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Decoded parameters.
  public var tokens: [TW_EthereumAbi_Proto_Token] = []

  /// error code, 0 is ok, other codes will be treated as errors
  public var error: TW_EthereumAbi_Proto_AbiError = .ok

  /// error code description
  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Decode an Eth ABI value.
public struct TW_EthereumAbi_Proto_ValueDecodingInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An encoded value to be decoded.
  public var encoded: Data = Data()

  /// A type of the parameter.
  /// Example: "bytes[32]".
  /// Please note `tuple` is not supported.
  public var paramType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TW_EthereumAbi_Proto_ValueDecodingOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Decoded parameter.
  public var token: TW_EthereumAbi_Proto_Token {
    get {return _token ?? TW_EthereumAbi_Proto_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  /// Decoded parameter as a string.
  public var paramStr: String = String()

  /// error code, 0 is ok, other codes will be treated as errors
  public var error: TW_EthereumAbi_Proto_AbiError = .ok

  /// error code description
  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: TW_EthereumAbi_Proto_Token? = nil
}

/// Encode a function call to Eth ABI binary.
public struct TW_EthereumAbi_Proto_FunctionEncodingInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Function name.
  public var functionName: String = String()

  /// Parameters to be encoded.
  public var tokens: [TW_EthereumAbi_Proto_Token] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TW_EthereumAbi_Proto_FunctionEncodingOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The function type signature.
  /// Example: "baz(int32,uint256)"
  public var functionType: String = String()

  /// An encoded smart contract call with a prefixed function signature (4 bytes).
  public var encoded: Data = Data()

  /// error code, 0 is ok, other codes will be treated as errors
  public var error: TW_EthereumAbi_Proto_AbiError = .ok

  /// error code description
  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Return the function type signature, of the form "baz(int32,uint256)".
public struct TW_EthereumAbi_Proto_FunctionGetTypeInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Function signature. Includes function inputs if they are.
  /// Examples:
  /// - `functionName()`
  /// - `functionName()`
  /// - `functionName(bool)`
  /// - `functionName(uint256,bytes32)`
  public var functionName: String = String()

  /// A set of ABI type parameters.
  public var inputs: [TW_EthereumAbi_Proto_Param] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TW.EthereumAbi.Proto"

extension TW_EthereumAbi_Proto_AbiError: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "Error_internal"),
    2: .same(proto: "Error_abi_mismatch"),
    3: .same(proto: "Error_invalid_abi"),
    4: .same(proto: "Error_invalid_param_type"),
    5: .same(proto: "Error_invalid_address_value"),
    6: .same(proto: "Error_invalid_uint_value"),
    7: .same(proto: "Error_missing_param_type"),
    8: .same(proto: "Error_missing_param_value"),
    9: .same(proto: "Error_decoding_data"),
    10: .same(proto: "Error_empty_type"),
  ]
}

extension TW_EthereumAbi_Proto_BoolType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BoolType"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_EthereumAbi_Proto_BoolType, rhs: TW_EthereumAbi_Proto_BoolType) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_EthereumAbi_Proto_NumberNType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NumberNType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bits"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.bits) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bits != 0 {
      try visitor.visitSingularUInt32Field(value: self.bits, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_EthereumAbi_Proto_NumberNType, rhs: TW_EthereumAbi_Proto_NumberNType) -> Bool {
    if lhs.bits != rhs.bits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_EthereumAbi_Proto_StringType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StringType"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_EthereumAbi_Proto_StringType, rhs: TW_EthereumAbi_Proto_StringType) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_EthereumAbi_Proto_AddressType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddressType"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_EthereumAbi_Proto_AddressType, rhs: TW_EthereumAbi_Proto_AddressType) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_EthereumAbi_Proto_ArrayType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArrayType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "element_type"),
  ]

  fileprivate class _StorageClass {
    var _elementType: TW_EthereumAbi_Proto_ParamType? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _elementType = source._elementType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._elementType) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._elementType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_EthereumAbi_Proto_ArrayType, rhs: TW_EthereumAbi_Proto_ArrayType) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._elementType != rhs_storage._elementType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_EthereumAbi_Proto_FixedArrayType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FixedArrayType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
    2: .standard(proto: "element_type"),
  ]

  fileprivate class _StorageClass {
    var _size: UInt64 = 0
    var _elementType: TW_EthereumAbi_Proto_ParamType? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _size = source._size
      _elementType = source._elementType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._size) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._elementType) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._size != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._size, fieldNumber: 1)
      }
      try { if let v = _storage._elementType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_EthereumAbi_Proto_FixedArrayType, rhs: TW_EthereumAbi_Proto_FixedArrayType) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._size != rhs_storage._size {return false}
        if _storage._elementType != rhs_storage._elementType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_EthereumAbi_Proto_ByteArrayType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ByteArrayType"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_EthereumAbi_Proto_ByteArrayType, rhs: TW_EthereumAbi_Proto_ByteArrayType) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_EthereumAbi_Proto_ByteArrayFixType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ByteArrayFixType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.size) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.size != 0 {
      try visitor.visitSingularUInt64Field(value: self.size, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_EthereumAbi_Proto_ByteArrayFixType, rhs: TW_EthereumAbi_Proto_ByteArrayFixType) -> Bool {
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_EthereumAbi_Proto_TupleType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TupleType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.params) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.params.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.params, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_EthereumAbi_Proto_TupleType, rhs: TW_EthereumAbi_Proto_TupleType) -> Bool {
    if lhs.params != rhs.params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_EthereumAbi_Proto_Param: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Param"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "param"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._param) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._param {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_EthereumAbi_Proto_Param, rhs: TW_EthereumAbi_Proto_Param) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._param != rhs._param {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_EthereumAbi_Proto_ParamType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ParamType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "boolean"),
    2: .standard(proto: "number_int"),
    3: .standard(proto: "number_uint"),
    7: .standard(proto: "string_param"),
    8: .same(proto: "address"),
    9: .standard(proto: "byte_array"),
    10: .standard(proto: "byte_array_fix"),
    14: .same(proto: "array"),
    15: .standard(proto: "fixed_array"),
    19: .same(proto: "tuple"),
  ]

  fileprivate class _StorageClass {
    var _param: TW_EthereumAbi_Proto_ParamType.OneOf_Param?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _param = source._param
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: TW_EthereumAbi_Proto_BoolType?
          var hadOneofValue = false
          if let current = _storage._param {
            hadOneofValue = true
            if case .boolean(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._param = .boolean(v)
          }
        }()
        case 2: try {
          var v: TW_EthereumAbi_Proto_NumberNType?
          var hadOneofValue = false
          if let current = _storage._param {
            hadOneofValue = true
            if case .numberInt(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._param = .numberInt(v)
          }
        }()
        case 3: try {
          var v: TW_EthereumAbi_Proto_NumberNType?
          var hadOneofValue = false
          if let current = _storage._param {
            hadOneofValue = true
            if case .numberUint(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._param = .numberUint(v)
          }
        }()
        case 7: try {
          var v: TW_EthereumAbi_Proto_StringType?
          var hadOneofValue = false
          if let current = _storage._param {
            hadOneofValue = true
            if case .stringParam(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._param = .stringParam(v)
          }
        }()
        case 8: try {
          var v: TW_EthereumAbi_Proto_AddressType?
          var hadOneofValue = false
          if let current = _storage._param {
            hadOneofValue = true
            if case .address(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._param = .address(v)
          }
        }()
        case 9: try {
          var v: TW_EthereumAbi_Proto_ByteArrayType?
          var hadOneofValue = false
          if let current = _storage._param {
            hadOneofValue = true
            if case .byteArray(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._param = .byteArray(v)
          }
        }()
        case 10: try {
          var v: TW_EthereumAbi_Proto_ByteArrayFixType?
          var hadOneofValue = false
          if let current = _storage._param {
            hadOneofValue = true
            if case .byteArrayFix(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._param = .byteArrayFix(v)
          }
        }()
        case 14: try {
          var v: TW_EthereumAbi_Proto_ArrayType?
          var hadOneofValue = false
          if let current = _storage._param {
            hadOneofValue = true
            if case .array(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._param = .array(v)
          }
        }()
        case 15: try {
          var v: TW_EthereumAbi_Proto_FixedArrayType?
          var hadOneofValue = false
          if let current = _storage._param {
            hadOneofValue = true
            if case .fixedArray(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._param = .fixedArray(v)
          }
        }()
        case 19: try {
          var v: TW_EthereumAbi_Proto_TupleType?
          var hadOneofValue = false
          if let current = _storage._param {
            hadOneofValue = true
            if case .tuple(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._param = .tuple(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      switch _storage._param {
      case .boolean?: try {
        guard case .boolean(let v)? = _storage._param else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .numberInt?: try {
        guard case .numberInt(let v)? = _storage._param else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .numberUint?: try {
        guard case .numberUint(let v)? = _storage._param else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .stringParam?: try {
        guard case .stringParam(let v)? = _storage._param else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .address?: try {
        guard case .address(let v)? = _storage._param else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .byteArray?: try {
        guard case .byteArray(let v)? = _storage._param else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .byteArrayFix?: try {
        guard case .byteArrayFix(let v)? = _storage._param else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .array?: try {
        guard case .array(let v)? = _storage._param else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .fixedArray?: try {
        guard case .fixedArray(let v)? = _storage._param else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .tuple?: try {
        guard case .tuple(let v)? = _storage._param else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_EthereumAbi_Proto_ParamType, rhs: TW_EthereumAbi_Proto_ParamType) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._param != rhs_storage._param {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_EthereumAbi_Proto_NumberNParam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NumberNParam"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bits"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.bits) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bits != 0 {
      try visitor.visitSingularUInt32Field(value: self.bits, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_EthereumAbi_Proto_NumberNParam, rhs: TW_EthereumAbi_Proto_NumberNParam) -> Bool {
    if lhs.bits != rhs.bits {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_EthereumAbi_Proto_ArrayParam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArrayParam"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "element_type"),
    2: .same(proto: "elements"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._elementType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.elements) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._elementType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.elements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elements, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_EthereumAbi_Proto_ArrayParam, rhs: TW_EthereumAbi_Proto_ArrayParam) -> Bool {
    if lhs._elementType != rhs._elementType {return false}
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_EthereumAbi_Proto_TupleParam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TupleParam"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.params) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.params.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.params, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_EthereumAbi_Proto_TupleParam, rhs: TW_EthereumAbi_Proto_TupleParam) -> Bool {
    if lhs.params != rhs.params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_EthereumAbi_Proto_Token: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Token"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "boolean"),
    3: .standard(proto: "number_int"),
    4: .standard(proto: "number_uint"),
    7: .standard(proto: "string_value"),
    8: .same(proto: "address"),
    9: .standard(proto: "byte_array"),
    10: .standard(proto: "byte_array_fix"),
    14: .same(proto: "array"),
    15: .standard(proto: "fixed_array"),
    19: .same(proto: "tuple"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.token != nil {try decoder.handleConflictingOneOf()}
          self.token = .boolean(v)
        }
      }()
      case 3: try {
        var v: TW_EthereumAbi_Proto_NumberNParam?
        var hadOneofValue = false
        if let current = self.token {
          hadOneofValue = true
          if case .numberInt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.token = .numberInt(v)
        }
      }()
      case 4: try {
        var v: TW_EthereumAbi_Proto_NumberNParam?
        var hadOneofValue = false
        if let current = self.token {
          hadOneofValue = true
          if case .numberUint(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.token = .numberUint(v)
        }
      }()
      case 7: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.token != nil {try decoder.handleConflictingOneOf()}
          self.token = .stringValue(v)
        }
      }()
      case 8: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.token != nil {try decoder.handleConflictingOneOf()}
          self.token = .address(v)
        }
      }()
      case 9: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.token != nil {try decoder.handleConflictingOneOf()}
          self.token = .byteArray(v)
        }
      }()
      case 10: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.token != nil {try decoder.handleConflictingOneOf()}
          self.token = .byteArrayFix(v)
        }
      }()
      case 14: try {
        var v: TW_EthereumAbi_Proto_ArrayParam?
        var hadOneofValue = false
        if let current = self.token {
          hadOneofValue = true
          if case .array(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.token = .array(v)
        }
      }()
      case 15: try {
        var v: TW_EthereumAbi_Proto_ArrayParam?
        var hadOneofValue = false
        if let current = self.token {
          hadOneofValue = true
          if case .fixedArray(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.token = .fixedArray(v)
        }
      }()
      case 19: try {
        var v: TW_EthereumAbi_Proto_TupleParam?
        var hadOneofValue = false
        if let current = self.token {
          hadOneofValue = true
          if case .tuple(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.token = .tuple(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    switch self.token {
    case .boolean?: try {
      guard case .boolean(let v)? = self.token else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case .numberInt?: try {
      guard case .numberInt(let v)? = self.token else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .numberUint?: try {
      guard case .numberUint(let v)? = self.token else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.token else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }()
    case .address?: try {
      guard case .address(let v)? = self.token else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    }()
    case .byteArray?: try {
      guard case .byteArray(let v)? = self.token else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
    }()
    case .byteArrayFix?: try {
      guard case .byteArrayFix(let v)? = self.token else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 10)
    }()
    case .array?: try {
      guard case .array(let v)? = self.token else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .fixedArray?: try {
      guard case .fixedArray(let v)? = self.token else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .tuple?: try {
      guard case .tuple(let v)? = self.token else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_EthereumAbi_Proto_Token, rhs: TW_EthereumAbi_Proto_Token) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_EthereumAbi_Proto_ContractCallDecodingInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContractCallDecodingInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "encoded"),
    2: .standard(proto: "smart_contract_abi_json"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.encoded) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.smartContractAbiJson) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.encoded.isEmpty {
      try visitor.visitSingularBytesField(value: self.encoded, fieldNumber: 1)
    }
    if !self.smartContractAbiJson.isEmpty {
      try visitor.visitSingularStringField(value: self.smartContractAbiJson, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_EthereumAbi_Proto_ContractCallDecodingInput, rhs: TW_EthereumAbi_Proto_ContractCallDecodingInput) -> Bool {
    if lhs.encoded != rhs.encoded {return false}
    if lhs.smartContractAbiJson != rhs.smartContractAbiJson {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_EthereumAbi_Proto_ContractCallDecodingOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContractCallDecodingOutput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "decoded_json"),
    2: .same(proto: "tokens"),
    3: .same(proto: "error"),
    4: .standard(proto: "error_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.decodedJson) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.error) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.decodedJson.isEmpty {
      try visitor.visitSingularStringField(value: self.decodedJson, fieldNumber: 1)
    }
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 2)
    }
    if self.error != .ok {
      try visitor.visitSingularEnumField(value: self.error, fieldNumber: 3)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_EthereumAbi_Proto_ContractCallDecodingOutput, rhs: TW_EthereumAbi_Proto_ContractCallDecodingOutput) -> Bool {
    if lhs.decodedJson != rhs.decodedJson {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs.error != rhs.error {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_EthereumAbi_Proto_AbiParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AbiParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.params) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.params.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.params, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_EthereumAbi_Proto_AbiParams, rhs: TW_EthereumAbi_Proto_AbiParams) -> Bool {
    if lhs.params != rhs.params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_EthereumAbi_Proto_ParamsDecodingInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ParamsDecodingInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "encoded"),
    2: .standard(proto: "abi_json"),
    3: .standard(proto: "abi_params"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.encoded) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.abi != nil {try decoder.handleConflictingOneOf()}
          self.abi = .abiJson(v)
        }
      }()
      case 3: try {
        var v: TW_EthereumAbi_Proto_AbiParams?
        var hadOneofValue = false
        if let current = self.abi {
          hadOneofValue = true
          if case .abiParams(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.abi = .abiParams(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.encoded.isEmpty {
      try visitor.visitSingularBytesField(value: self.encoded, fieldNumber: 1)
    }
    switch self.abi {
    case .abiJson?: try {
      guard case .abiJson(let v)? = self.abi else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .abiParams?: try {
      guard case .abiParams(let v)? = self.abi else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_EthereumAbi_Proto_ParamsDecodingInput, rhs: TW_EthereumAbi_Proto_ParamsDecodingInput) -> Bool {
    if lhs.encoded != rhs.encoded {return false}
    if lhs.abi != rhs.abi {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_EthereumAbi_Proto_ParamsDecodingOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ParamsDecodingOutput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokens"),
    2: .same(proto: "error"),
    3: .standard(proto: "error_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.error) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 1)
    }
    if self.error != .ok {
      try visitor.visitSingularEnumField(value: self.error, fieldNumber: 2)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_EthereumAbi_Proto_ParamsDecodingOutput, rhs: TW_EthereumAbi_Proto_ParamsDecodingOutput) -> Bool {
    if lhs.tokens != rhs.tokens {return false}
    if lhs.error != rhs.error {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_EthereumAbi_Proto_ValueDecodingInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValueDecodingInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "encoded"),
    2: .standard(proto: "param_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.encoded) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.paramType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.encoded.isEmpty {
      try visitor.visitSingularBytesField(value: self.encoded, fieldNumber: 1)
    }
    if !self.paramType.isEmpty {
      try visitor.visitSingularStringField(value: self.paramType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_EthereumAbi_Proto_ValueDecodingInput, rhs: TW_EthereumAbi_Proto_ValueDecodingInput) -> Bool {
    if lhs.encoded != rhs.encoded {return false}
    if lhs.paramType != rhs.paramType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_EthereumAbi_Proto_ValueDecodingOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValueDecodingOutput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .standard(proto: "param_str"),
    3: .same(proto: "error"),
    4: .standard(proto: "error_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.paramStr) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.error) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.paramStr.isEmpty {
      try visitor.visitSingularStringField(value: self.paramStr, fieldNumber: 2)
    }
    if self.error != .ok {
      try visitor.visitSingularEnumField(value: self.error, fieldNumber: 3)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_EthereumAbi_Proto_ValueDecodingOutput, rhs: TW_EthereumAbi_Proto_ValueDecodingOutput) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.paramStr != rhs.paramStr {return false}
    if lhs.error != rhs.error {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_EthereumAbi_Proto_FunctionEncodingInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FunctionEncodingInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "function_name"),
    2: .same(proto: "tokens"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.functionName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.functionName.isEmpty {
      try visitor.visitSingularStringField(value: self.functionName, fieldNumber: 1)
    }
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_EthereumAbi_Proto_FunctionEncodingInput, rhs: TW_EthereumAbi_Proto_FunctionEncodingInput) -> Bool {
    if lhs.functionName != rhs.functionName {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_EthereumAbi_Proto_FunctionEncodingOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FunctionEncodingOutput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "function_type"),
    2: .same(proto: "encoded"),
    3: .same(proto: "error"),
    4: .standard(proto: "error_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.functionType) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.encoded) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.error) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.functionType.isEmpty {
      try visitor.visitSingularStringField(value: self.functionType, fieldNumber: 1)
    }
    if !self.encoded.isEmpty {
      try visitor.visitSingularBytesField(value: self.encoded, fieldNumber: 2)
    }
    if self.error != .ok {
      try visitor.visitSingularEnumField(value: self.error, fieldNumber: 3)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_EthereumAbi_Proto_FunctionEncodingOutput, rhs: TW_EthereumAbi_Proto_FunctionEncodingOutput) -> Bool {
    if lhs.functionType != rhs.functionType {return false}
    if lhs.encoded != rhs.encoded {return false}
    if lhs.error != rhs.error {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_EthereumAbi_Proto_FunctionGetTypeInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FunctionGetTypeInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "function_name"),
    2: .same(proto: "inputs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.functionName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.functionName.isEmpty {
      try visitor.visitSingularStringField(value: self.functionName, fieldNumber: 1)
    }
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_EthereumAbi_Proto_FunctionGetTypeInput, rhs: TW_EthereumAbi_Proto_FunctionGetTypeInput) -> Bool {
    if lhs.functionName != rhs.functionName {return false}
    if lhs.inputs != rhs.inputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
